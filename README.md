# goit-algo-hw-09

## Домашня робота №9

## Опис домашнього завдання

У конспекті ми розглянули приклад про розбиття суми на монети. Маємо набір монет ```[50, 25, 10, 5, 2, 1]```
Уявіть, що ви розробляєте систему для касового апарату, яка повинна визначити оптимальний спосіб видачі решти покупцеві.

Вам необхідно написати дві функції для касової системи, яка видає решту покупцеві:

1) Функція жадібного алгоритму find_coins_greedy. Ця функція повинна приймати суму, яку потрібно видати покупцеві, і повертати словник із кількістю монет кожного номіналу, що використовуються для формування цієї суми. Наприклад, для суми ```113``` це буде словник ```{50: 2, 10: 1, 2: 1, 1: 1}```. Алгоритм повинен бути жадібним, тобто спочатку вибирати найбільш доступні номінали монет.
2) Функція динамічного програмування find_min_coins. Ця функція також повинна приймати суму для видачі решти, але використовувати метод динамічного програмування, щоб знайти мінімальну кількість монет, необхідних для формування цієї суми. Функція повинна повертати словник із номіналами монет та їх кількістю для досягнення заданої суми найефективнішим способом. Наприклад, для суми ```113``` це буде словник ```{1: 1, 2: 1, 10: 1, 50: 2}```

Порівняйте ефективність жадібного алгоритму та алгоритму динамічного програмування, базуючись на часі їх виконання або О великому та звертаючи увагу на їхню продуктивність при великих сумах. Висвітліть, як вони справляються з великими сумами та чому один алгоритм може бути більш ефективним за інший у певних ситуаціях. Свої висновки додайте у файл readme.md домашнього завдання

### Аналіз ефективності обох алгоритмів


1. Жадібний Алгоритм (find_coins_greedy)

    Часова Складність: $O(N)$, де $N$ — це кількість номіналів монет (у нашому випадку $N=6$).

    Жадібний алгоритм виконує фіксовану кількість операцій (ділення та знаходження залишку) для кожного номіналу монет, незалежно від розміру цільової суми. Це робить його надзвичайно швидким і константно ефективним навіть для дуже великих сум (наприклад, 1 000 000).

    Продуктивність при великих сумах дуже висока. Час виконання не залежить від величини суми, а лише від кількості типів монет.

    Але жадібний алгоритм не гарантує оптимального рішення, якщо система номіналів не є "стандартною" (наприклад, якщо б номінали були $[7, 5, 1]$, жадібний алгоритм для суми 10 дав би $7+1+1+1$ (4 монети), тоді як оптимально $5+5$ (2 монети)).

2. Динамічне Програмування (find_min_coins)

    Часова Складність: $O(M \cdot N)$, де $M$ — це цільова сума (amount), а $N$ — кількість номіналів монет.

    Алгоритм динамічного программування створює таблицю (або масив/список) розміром $M+1$ і заповнює її, проходячи через всі проміжні суми від 1 до $M$ для кожного номіналу $N$.

    Це гарантує оптимальність, але вимагає значно більше обчислень.Продуктивність при великих сумах: Низька/Погана. Час виконання зростає лінійно разом зі збільшенням цільової суми ($M$).

    Наприклад, для суми 5000, ДП буде приблизно у 500 разів повільніше, ніж для суми 10.

    З іншого боку алгоритм динамічного програмування завжди гарантує оптимальне рішення (мінімальну кількість монет) для будь-якого набору номіналів.
